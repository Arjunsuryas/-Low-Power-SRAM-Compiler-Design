// RISC-V Arithmetic Logic Unit
module riscv_alu
    import riscv_defines::*;
(
    input  logic [XLEN-1:0]  operand_a,
    input  logic [XLEN-1:0]  operand_b,
    input  alu_op_e          alu_op,
    output logic [XLEN-1:0]  result,
    output logic             zero_flag
);

    logic [XLEN-1:0] alu_result;
    logic [4:0]      shift_amount;
    
    assign shift_amount = operand_b[4:0];
    
    always_comb begin
        case (alu_op)
            ALU_ADD:    alu_result = operand_a + operand_b;
            ALU_SUB:    alu_result = operand_a - operand_b;
            ALU_AND:    alu_result = operand_a & operand_b;
            ALU_OR:     alu_result = operand_a | operand_b;
            ALU_XOR:    alu_result = operand_a ^ operand_b;
            ALU_SLT:    alu_result = ($signed(operand_a) < $signed(operand_b)) ? 32'h1 : 32'h0;
            ALU_SLTU:   alu_result = (operand_a < operand_b) ? 32'h1 : 32'h0;
            ALU_SLL:    alu_result = operand_a << shift_amount;
            ALU_SRL:    alu_result = operand_a >> shift_amount;
            ALU_SRA:    alu_result = $signed(operand_a) >>> shift_amount;
            ALU_LUI:    alu_result = operand_b;
            ALU_AUIPC:  alu_result = operand_a + operand_b;
            default:    alu_result = 32'h0;
        endcase
    end
    
    assign result = alu_result;
    assign zero_flag = (alu_result == 32'h0);

endmodule
