// RISC-V Instruction Decoder
module riscv_decoder
    import riscv_defines::*;
(
    input  logic [ILEN-1:0]  instruction,
    output logic [XLEN-1:0]  immediate,
    output control_t         control_signals,
    output logic [REGFILE_ADDR_WIDTH-1:0] rs1_addr,
    output logic [REGFILE_ADDR_WIDTH-1:0] rs2_addr,
    output logic [REGFILE_ADDR_WIDTH-1:0] rd_addr
);

    // Instruction fields
    logic [6:0]  opcode;
    logic [2:0]  funct3;
    logic [6:0]  funct7;
    
    assign opcode = instruction[6:0];
    assign funct3 = instruction[14:12];
    assign funct7 = instruction[31:25];
    assign rs1_addr = instruction[19:15];
    assign rs2_addr = instruction[24:20];
    assign rd_addr = instruction[11:7];
    
    // Immediate generation
    always_comb begin
        case (opcode)
            OPCODE_OP_IMM, OPCODE_JALR, OPCODE_LOAD: begin
                // I-type immediate
                immediate = {{20{instruction[31]}}, instruction[31:20]};
            end
            OPCODE_STORE: begin
                // S-type immediate
                immediate = {{20{instruction[31]}}, instruction[31:25], instruction[11:7]};
            end
            OPCODE_BRANCH: begin
                // B-type immediate
                immediate = {{19{instruction[31]}}, instruction[31], instruction[7], 
                            instruction[30:25], instruction[11:8], 1'b0};
            end
            OPCODE_LUI, OPCODE_AUIPC: begin
                // U-type immediate
                immediate = {instruction[31:12], 12'h0};
            end
            OPCODE_JAL: begin
                // J-type immediate
                immediate = {{11{instruction[31]}}, instruction[31], instruction[19:12],
                            instruction[20], instruction[30:21], 1'b0};
            end
            default: begin
                immediate = 32'h0;
            end
        endcase
    end
    
    // Control signal generation
    always_comb begin
        // Default values
        control_signals = '{
            reg_write: 1'b0,
            mem_read: 1'b0,
            mem_write: 1'b0,
            branch: 1'b0,
            jump: 1'b0,
            alu_src: 1'b0,
            reg_write_src: 2'b00,
            alu_op: ALU_ADD,
            mem_type: MEM_WORD,
            branch_type: BRANCH_EQ
        };
        
        case (opcode)
            OPCODE_LUI: begin
                control_signals.reg_write = 1'b1;
                control_signals.alu_src = 1'b1;
                control_signals.alu_op = ALU_LUI;
                control_signals.reg_write_src = 2'b00; // ALU result
            end
            
            OPCODE_AUIPC: begin
                control_signals.reg_write = 1'b1;
                control_signals.alu_src = 1'b1;
                control_signals.alu_op = ALU_AUIPC;
                control_signals.reg_write_src = 2'b00; // ALU result
            end
            
            OPCODE_JAL: begin
                control_signals.reg_write = 1'b1;
                control_signals.jump = 1'b1;
                control_signals.reg_write_src = 2'b10; // PC + 4
            end
            
            OPCODE_JALR: begin
                control_signals.reg_write = 1'b1;
                control_signals.jump = 1'b1;
                control_signals.alu_src = 1'b1;
                control_signals.alu_op = ALU_ADD;
                control_signals.reg_write_src = 2'b10; // PC + 4
            end
            
            OPCODE_BRANCH: begin
                control_signals.branch = 1'b1;
                control_signals.alu_op = ALU_SUB;
                case (funct3)
                    3'b000: control_signals.branch_type = BRANCH_EQ;
                    3'b001: control_signals.branch_type = BRANCH_NE;
                    3'b100: control_signals.branch_type = BRANCH_LT;
                    3'b101: control_signals.branch_type = BRANCH_GE;
                    3'b110: control_signals.branch_type = BRANCH_LTU;
                    3'b111: control_signals.branch_type = BRANCH_GEU;
                    default: control_signals.branch_type = BRANCH_EQ;
                endcase
            end
            
            OPCODE_LOAD: begin
                control_signals.reg_write = 1'b1;
                control_signals.mem_read = 1'b1;
                control_signals.alu_src = 1'b1;
                control_signals.alu_op = ALU_ADD;
                control_signals.reg_write_src = 2'b01; // Memory data
                case (funct3)
                    3'b000: control_signals.mem_type = MEM_BYTE;
                    3'b001: control_signals.mem_type = MEM_HALF;
                    3'b010: control_signals.mem_type = MEM_WORD;
                    3'b100: control_signals.mem_type = MEM_BYTE_U;
                    3'b101: control_signals.mem_type = MEM_HALF_U;
                    default: control_signals.mem_type = MEM_WORD;
                endcase
            end
            
            OPCODE_STORE: begin
                control_signals.mem_write = 1'b1;
                control_signals.alu_src = 1'b1;
                control_signals.alu_op = ALU_ADD;
                case (funct3)
                    3'b000: control_signals.mem_type = MEM_BYTE;
                    3'b001: control_signals.mem_type = MEM_HALF;
                    3'b010: control_signals.mem_type = MEM_WORD;
                    default: control_signals.mem_type = MEM_WORD;
                endcase
            end
            
            OPCODE_OP_IMM: begin
                control_signals.reg_write = 1'b1;
                control_signals.alu_src = 1'b1;
                control_signals.reg_write_src = 2'b00; // ALU result
                case (funct3)
                    3'b000: control_signals.alu_op = ALU_ADD;
                    3'b010: control_signals.alu_op = ALU_SLT;
                    3'b011: control_signals.alu_op = ALU_SLTU;
                    3'b100: control_signals.alu_op = ALU_XOR;
                    3'b110: control_signals.alu_op = ALU_OR;
                    3'b111: control_signals.alu_op = ALU_AND;
                    3'b001: control_signals.alu_op = ALU_SLL;
                    3'b101: control_signals.alu_op = (funct7[5]) ? ALU_SRA : ALU_SRL;
                    default: control_signals.alu_op = ALU_ADD;
                endcase
            end
            
            OPCODE_OP: begin
                control_signals.reg_write = 1'b1;
                control_signals.reg_write_src = 2'b00; // ALU result
                case (funct3)
                    3'b000: control_signals.alu_op = (funct7[5]) ? ALU_SUB : ALU_ADD;
                    3'b001: control_signals.alu_op = ALU_SLL;
                    3'b010: control_signals.alu_op = ALU_SLT;
                    3'b011: control_signals.alu_op = ALU_SLTU;
                    3'b100: control_signals.alu_op = ALU_XOR;
                    3'b101: control_signals.alu_op = (funct7[5]) ? ALU_SRA : ALU_SRL;
                    3'b110: control_signals.alu_op = ALU_OR;
                    3'b111: control_signals.alu_op = ALU_AND;
                    default: control_signals.alu_op = ALU_ADD;
                endcase
            end
            
            default: begin
                // Keep default values
            end
        endcase
    end

endmodule
